/**
 * Utility functions for generating trip descriptions from segments
 */

interface SegmentData {
  startTitle: string;
  endTitle: string;
  order?: number;
}

/**
 * Generate a trip description from segments in the format:
 * "Location1 → Location2 → Location3"
 * 
 * @param segments - Array of segments with startTitle and endTitle
 * @returns Generated description string
 */
export function generateTripDescription(segments: SegmentData[]): string {
  if (!segments || segments.length === 0) {
    return "";
  }

  // Sort segments by order if available
  const sortedSegments = [...segments].sort((a, b) => {
    if (a.order !== undefined && b.order !== undefined) {
      return a.order - b.order;
    }
    return 0;
  });

  // Collect all locations in order
  const locations: string[] = [];
  
  for (let i = 0; i < sortedSegments.length; i++) {
    const segment = sortedSegments[i];
    
    // Add start location if it's the first segment or different from previous end
    if (i === 0) {
      locations.push(segment.startTitle);
    } else {
      const prevSegment = sortedSegments[i - 1];
      // Only add if different from previous end location
      if (segment.startTitle !== prevSegment.endTitle) {
        locations.push(segment.startTitle);
      }
    }
    
    // Always add end location
    locations.push(segment.endTitle);
  }

  // Remove consecutive duplicates
  const uniqueLocations = locations.filter((loc, idx) => {
    if (idx === 0) return true;
    return loc !== locations[idx - 1];
  });

  // Join with arrow separator
  return uniqueLocations.join(" → ");
}

/**
 * Check if a description appears to be auto-generated
 * (useful for determining if we should update it)
 * 
 * @param description - The description to check
 * @returns true if it looks auto-generated
 */
export function isAutoGeneratedDescription(description: string): boolean {
  // Auto-generated descriptions contain the arrow separator
  return description.includes(" → ");
}
